import           Data.Char
import           Unit

{-
https://en.wikipedia.org/wiki/ROT13

Цялата идея на rot13 е да „завъртим“ буквите от низа с 13 напред. За целта ще
имплементираме еднократно завъртане с буква напред и ще го приложим 13 пъти.
Разбира се, за целта може директно да се ползва артиметика и остатъци при
деление на 26.
За да се реализира алгоритъмът ползваме функциите chr и ord, които превръщат
съответно число->знак и знак->число. Под „число“ разбирайте код на знака от
ASCII таблицата.
-}

-- „Завърта“ един знак с едно встрани.
returnNext :: Char -> Char
returnNext c
-- Премахваме всички знаци, които не са букви.
-- (В ASCII таблицата са първо главните букви, след което малките.)
  | c < 'A' || (c > 'Z' && c < 'a') || c > 'z' = c
-- Долните две условия правят завъртането в „края“ на азбуката:
  | c == 'Z' = 'A'
  | c == 'z' = 'a'
-- И накрая - извикването за нормална буква, която не е z/Z:
  | otherwise = chr (ord c + 1)

-- примерна реализация на използваната по-долу iterate
iterate' :: (t -> t) -> t -> [t]
iterate' f x = x : iterate' f (f x)

-- Завърта един знак. прилагаме 13 пъти функцията returnNext като ползваме 13-ия
-- елемент от безкрайния списък, върнат от iterate: x, f(x), f(f(x)), ...
-- Това е лесен начин за вземане на n-та композиция на дадена функция.
rot13Char :: Char -> Char
rot13Char c = iterate returnNext c !! 13

-- rot13 върху низ. Просто го прилагаме върху отделните знаци.
rot13 :: String -> String
-- (сигнатурата може да е и rot13 :: [Char] -> [Char])
rot13 = map rot13Char

main = do {
  assertEqual "Uryyb, jbeyq!" $ rot13 "Hello, world!";
  -- Пример със знаци, чиито ASCII кодове се намират между големите и малките
  -- английски букви:
  assertEqual "[`" $ rot13 "[`"
}
