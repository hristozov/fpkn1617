; Даден е непразен списък L от числа (a1 a2 ... an), такъв че отначало
; елементите на L строго намаляват, после строго растат, след това отново строго
; тамаляват, после строго растат и т.н. Да се напише програма, която построява
; списък, съдържащ минималния елемент на първата подредица, максималният елемент
; на втората подредица, минималният елемент на третата подредица, максималният
; елемент на четвъртата подредица и т.н. Например, ако:
; L = (10 8 6 4 1 3 5 6 4 2 1 9 12 16 14 13 10), програмата да намери списъка (1 6 1 16 10).
;
; Тук решението ще включва две взаимно-ресурсивни функции, които се грижат за
; случаите на растящи и намаляващи подредици в дадения списък. Обърнете
; внимание, че в дъното на рекурсията специално се грижим последния елемент да
; бъде включен.
(define (sequences l)
  (define (ascending l last)
    (cond
      ((null? l) '()) ; Всъщност, можем да минем и без това условие. Долното е достатъчно.
      ((null? (cdr l)) (list (car l)))
      ((< (car l) last) (cons last (descending l (car l))))
      (else (ascending (cdr l) (car l)))))
  (define (descending l last)
    (cond
      ((null? l) '()) ; И това условие е излишно.
      ((null? (cdr l)) (list (car l)))
      ((> (car l) last) (cons last (ascending l (car l))))
      (else (descending (cdr l) (car l)))))
  (descending l (+ (car l) 1)))
