(load "../../lib/scm/unit.scm")

; Тук и двете процедури правят почти същото като в derive - просто взимат за
; параметри и връщат като резултати двуаргументни процедури. За да намерим
; частната производна във всеки от случаите, ние диференцираме f само по един от
; параметрите му (x или y), като запазваме другия (съответно, y или x) без да го
; променяме и директно го подаваме на f.

(define (derive-x f)
  (lambda (x y)
    (let ((z (+ x 0.001)))
      (/ (- (f x y)
            (f z y))
         (- x z)))))

(define (derive-y f)
  (lambda (x y)
    (let ((z (+ y 0.001)))
      (/ (- (f x y)
            (f x z))
         (- y z)))))

(assert-approx 2
               0.01
               ((derive-x (lambda (x y) (+ (* 2 x) (* 3 y))))
                1337 1337))
(assert-approx 3
               0.01
               ((derive-y (lambda (x y) (+ (* 2 x) (* 3 y))))
                1337 1337))
